## 2.3 시스템 호출

**참고**

(이번에는 시스템의 호출에 관한 한 예시의 흐름이 담겨 있는 챕터이기 때문에, 원문의 내용을 내가 알아듣기 쉽게만 변형하여 원문 거의 그대로 작성하였다.)



시스템 호출은 운영체제가 제공하는 서비스에 대한 인터페이스를 제공한다.(운영체제를 만들 때 구현해야 하는 기능.) 하드웨어를 직접 접근해야 하는 작업같이 저수준 작업은 어셈블리 명령을 사용하여 작성되어야 하더라도, 이러한 호출은 일반적으로 C와 C++언어로 작성된 형태로 제공된다.

시스템 호출은 이렇게 사용된다. 한 파일로부터 데이터를 읽어서 다른 파일로 복사하는 프로그램을 만든다고 가정하면, 프로그램이 필요로 하는 첫번째 입력은 입력파일과 출력파일의 이름일 것이다. 이 파일의 이름 두개를 지정하는 방법에는 여러가지 방법이 있지만 한 예로는 사용자에게 두 파일의 이름을 요청하는 것이다. 대화식 시스템에서 이러한 방법은 일련의 시스템 호출을 필요로 하는데, 먼저 화면에 프롬프트(cmd 실행시키면 나오는 검은색 창) 메시지를 나타내기 위하여, 그리고 두 파일을 정의하는 문자를 키보드로부터 읽기 위하여 필요하다. 마우스 기반 시스템에서는 통상 파일 이름의 메뉴가 윈도우에 나타난다. 이 때 사용자는 source(입력파일) 이름을 선택하기 위해 마우스를 사용하고, 목적 파일(출력파일) 이름을 지정하기 위한 윈도우가 오픈될 수 있다. 이 순차적인 작업은 많은 입출력 시스템 호출을 필요로 한다.

두 개의 파일 이름이 얻어지면, 프로그램은 반드시 입력 파일을 오픈하고 출력 파일을 생성한다. 각각 이러한 연산은 또 다른 시스템 호출을 필요로 하며, 각 연산에 대해 오류가 발생할 수도 있다. 프로그램이 입력 파일을 오픈하려고 할 때, 그 파일에 대한 접근이 금지되어 있거나 그 이름을 가지는 파일이 존재하지 않을 경우가 있다.(no such file or directory) 이러한 경우 프로그램은 콘솔에 메시지를 출력하고(또다른 일련의 시스템 호출이다.) 그리고 비정상적으로 종료(마찬가지 시스템 호출)한다. 입력 파일이 존재할 경우, 새로운 출력 파일을 생성해야 한다. 이때 동일한 이름을 가진 출력 파일이 이미 존재하는 경우가 있다. 이 상황에서는 프로그램을 중단(시스템호출.)하거나 또는 기존 파일을 삭제(시..호)한 후, 새로운 파일을 생성(ㅅ...ㅎ)할 수도 있다. 대화형 시스템에서 또다른 방법은 기존의 파일을 대체할 것인지 혹은 프로그램을 중단할 것인지를 사용자에게 물어보는(프롬프트 메세지의 출력과 터미널로부터 응답을 읽기 위한 ㅅㅎ)것이다.

이제 두 파일이 구축되면, 입력 파일로부터 읽어서(ㅅㅎ) 출력파일에 기록(ㅅㅎ)하는 루프에 들어가게 된다. 각 읽기와 쓰기는 가능한 여러가지 오류 상황의 정보를 반환해야 한다. 입력의 경우 프로그램이 파일의 끝에 도달하거나 읽기 중에 하드웨어 오류(패리티 오류 인데 패리티란 맨 밑에서 후술하겠다!)가 발생할 수도 있다. 쓰기 연산 시 출력 장치에 따라 여러가지 오류들(디스크 공간 부족, 프린터 종이 부족 등)이 발생할 수도 있다.

마지막으로 전체 파일이 복사된 후, 프로그램은 두 개의 파일을 닫고(ㅅㅎ), 콘솔 또는 윈도우에 메시지를 기록하고(ㅅㅎ) 결국 정상적으로 종료(마지막 ㅅㅎ)하게 된다. 이렇게 간단한 프로그램이라도 운영체제의 시스템 호출을 많이 사용하게 된다.

![시스템 호출 예](C:\Users\moony\Desktop\시스템 호출 예.png)

이렇게 자세한 사항을 일반 사용자들은 알지 못하고, 응용 개발자들은 응용 프로그래밍 인터페이스(Application Programing Interface, API)에 따라 프로그램을 설계한다. 가장 대표적인 win32 API, POSIX 기반 시스템을 위한 POSIX API(UNIX, Linux, Max OS X를 포함한다.), JAVA API 등등이 있다.

보이지 않는 이면에서 API를 구성하는 함수들은 통상 응용 프로그래머를 대신하여 실제 시스템 호출을 호출한다.예를 들면 Win32 함수 CreateProcess()(프로세스 생성 함수)는 실제로 Windows 커널의 NTCreateProcess() 시스템 호출을 부른다. 왜  응용 프로그래머는 실제 시스템 호출을 부르는 것 보다 API에 따라 프로그래밍하는 것을 선호하는 것일까? 그 이유는 API에 따라 프로그래밍을 하면, 그 API를 지원하는 어느 시스템에서건 컴파일 되고 실행된다는 것을 기대할 수 있다.(실제로는 쉽지 않다.)(Java는 가상머신이 있어서 다른 환경에서도 같은 코드로 컴파일이 된다고 들었다. 이러한 이유의 대표적인 예가 아닐까) 게다가 실제 시스템 호출은 종종 좀더 자세한 명세가 필요하고, 프로그램 상에서 작업하기가 응용 프로그래머에게 가용한 API보다 더 어렵다.

프로그래밍 언어들을 위한 실행시간 지원 시스템(컴파일러에 포함된 라이브러리에 내장된 함수의 집합)은 운영체제가 제공하는 시스템 호출에 대한 연결로서 동작하는 시스템 호출 인터페이스를 제공한다.(시스템 호출로 연결시켜주는 인터페이스를 실행시간 지원 시스템이 가지고 있다.(제공해 준다.)) 이 시스템 호출 인터페이스는 API 함수의 호출을 가로재어 필요한 운영체제 시스템 호출을 부른다. 통상 각 시스템 호출에는 번호가 할당되고, 시스템 호출 인터페이스는 이 번호에따라 인덱스 되는 테이블을 유지한다. 시스템 호출 인터페이스는 의도하는 시스템 호출을 부르고 시스템 호출의 상태와 반환 값을 돌려준다.

시스템 호출 호출자는 시스템 호출이 어떻게 구현되고 실행중 무슨 작업을 하는지 아무 것도 알 필요가 없다. 그저 운영체제가 뭘 해줄 것인지만 이해하면 되기 때문에 운영체제 인터페이스에 대한 대부분의 자세한 내용은 API에 의해 프로그래머로부터 숨겨지고 실행시간 지원 라이브러리에 의해 관리된다.

운영체제에 매개변수를 전달하기 위해서는 세 가지의 일반적인 방법이 있다, 가장 간단한 방법은 매개변수를 레지스터 내에 전달하는 것이다. 하지만 레지스터의 용량보다 더 많은 매개변수가 있을 시에는 메모리 내의 블록이나 테이블에 저장되고, 그 주소값이 레지스터 내에 매개변수로 전달된다.(malloc으로 동적할당 하는 것 같다.)

매개변수는 프로그램에 의해 stack에 push될 수도 있고 운영체제에 의해 pop된다. 몇몇 운영체제는 블록이나 스택 방법을 선호한다.

