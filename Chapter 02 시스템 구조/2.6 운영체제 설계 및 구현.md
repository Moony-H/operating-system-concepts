## 2.6 운영체제 설계 및 구현

이번에는 우리가 운영체제를 설계하고 구현할 때 우리가 겪을 문제점을 논의해 보자.

### 2.6.1 설계 목표

시스템을 설계하는 데에 첫번째 문제점은 시스템의 목표와 명세를 정의하는 일이다. 시스템 설계는 최상위 수준에서는 하드웨어와 시스템 타입(일괄처리, 시분할, 단일 사용자, 다중 사용자, 분산, 실시간 혹운 범용)의 선택에 의해 영향을 받을 것이다. 이 최상위 설계 수준을 넘어서면, 요구 조건들을 명세하는 것이 훨씬 더 어렵다. 그러나 이러한 요구 조건은 근본적으로 사용자 목적과 시스템 목적의 두가지 기본 그룹으로 나눌 수 있다.

사용자들은 시스템이 몇몇 명백한 특성을 가지기를 원한다. 따라서 시스템은 사용하기 쉽고 편리하며, 배우기 쉽고, 믿을 수 있고, 안전하고, 신속해야 한다. 물론 이러한 명세는 어떻게 이러한 목적을 달성할 것인가에 대한 일반적인 합의가 없기 때문에 시스템 설계에 있어 특별히 유용하지는 않다.(***한마디로 정해진 답은 없다.***)

이와 유사하게 요구 조건들이 시스템을 설계, 생성, 유지, 조작해야 하는 사람들에 의해 정의된다. 즉, 운영체제는 설계, 구현, 유지 보수가 쉬워야 하며, 또한 적응성, 신뢰성, 무오류, 효울성을 가져야 한다.

### 2.6.2 메커니즘과 정책

한가지 중요한 원칙은 메커니즘으로부터 정책을 분리하는 것이다. 메커니즘은 어떤 일을 어떻게 할 것인가를 결정하는 것이고, 정책은 무엇을 할 것인가를 결정하는 것이다. 예를 들면, 타이머 구조(***타이머로 한 프로세스를 계속 돌리는걸 방지***)는 CPU 보호를 보장하기 위한 메커니즘이지만, 특정 사용자를 위해 타이머를 얼마나 오랫돈안 설정할 지를 결정하는 것은 정책적 결정이다.

정책과 메커니즘의 분리는 융통성을 위해 아주 중요하다. 정책은 장소나 시간에 따라 변경될 수 있다. 최악의 경우, 정책의 각 변경이 저변에 깔려 있는 메커니즘의 변경을 요구하게 된다. 정책의 변경에 민감하지 않은 일반적인 메커니즘이 보다 바람직하다.

스케줄링 메커니즘을 범용으로 구현하면 load-new-table 명령 하나로 다양한 정책 변경을 수용할 수 있다. 반대 방향으로는 극단적인 windows와 같은 시스템이 있는데, 여기에서는 시스템에 대한 전역적 외관과 느낌을 시행하기 위해 메커니즘과 정책이 시스템 내에 코드화되어 있다. 인터페이스 자체가 커널과 시스템 라이브러리에 내장되어 있기 때문에 모든 응용들은 유사한 인터페이스를 가진다.

정책 결정은 모든 자원 할당 문제에 있어 중요하다. 자원의 할당 여부를 결정할 필요가 있을 때마다 정책을 결정해야 한다. 질문이 무엇이 아니라 어떻게 일 때 마다, 반드시 결정되어야 하는 것은 메커니즘이다.

### 2.6.3 구현

운영체제가 설계되면, 반드시 구현되어야 한다. 전통적인 운영체제는 어셈블리어로 작성되었다. 그러나 지금은 거의 대부분 운영체제가 C나 C++과 같는 고급 언어로 작성된다.(***고급 언어일 수록 사람의 말과 비슷하다.***)

운영체제를 구현하기 위해 고급 언어나 최소한 시스템 구현 언어를 사용함으로써 생기는 장점은 그 언어가 응용프로그램을 위해 사용될 때 생기는 장점과 마찬가지이다. 즉, 코드를 빨리 작성할 수 있으며, 더욱 간결하고, 이해하기 쉽고, 디버그 하기도 쉽다. 추가로, 컴파일러 기술의 향상은 단순히 다시 컴파일하는 것만으로도 전체 운영체제를 위해 생성된 코드를 향상시킬 것이다. 마지막으로 고급언어 운영체제의 장점은 다른 하드웨어로 옮기는 일이 쉽다.

고급 언어의 운영체제 단점은 속도가 느리고 저장장치가 많이 소요되는 것이다. 그러나 이것은 현재의 시스템에서는 더 이상 주된 문제가 아니다.

운영체제의 주요 성능 향상은 우수한 어셈블리어 코드보다는 좋은 자료 구조와 알고리즘의 결과일 가능성이 크다. 게다가 운영체제가 크긴 하지만, 단지 소량의 코드만이 고성능에 중요하다. 아마도 메모리 관리자와 CPU스케줄러가 가장 중요한 루틴일 것이다. 시스템이 작성되어 정확히 작동하면, 병목 루틴을 확인할 수 있고, 동등한 어셈블리어로 대체될 수 있다.

