## 2.4 시스템 호출의 유형

시스템 호출은 프로세스 제어, 파일 조작, 장치 조작, 정보 유지 보수와 통신과 보호 등 다섯가지의 중요한 범주로 묶을 수 있다. 이 다섯가지를 간단히 살펴 보자.

### 2.4.1 프로세스 제어

실행중인 프로그램은 실행을 정상적, 또는 비정상적으로 끝낼 수 있어야 한다. 만약 실행중인 프로그램을 비정상 적으로 중지하기 위해 시스템 호출을 하거나 프로그램에 문제가 발생해 트랩을 유발할 경우 때때로 메모리 덤프가 행해지고 오류 메시지가 생성된다. 이 덤프는 디스크에 기록되고 문제의 원인을 결정하기 위해 디버거에 의해 검사될 수 있다. 

정상적, 비정상적인 상황에서 운영체제는 명령 해석기로 제어를 전달해야 한다. 명령 해석기는 이어 다음 명령을 읽는다. 대화식 시스템에서 명령 해석기는 단순히 다음 명령을 계속 실행하며, 사용자가 오류에 응답하는 적절한 명령을 내릴 것을 가정한다.(명령 해석기는 사용자가 오류에 대해 인지하고 그에 대한 해결책 혹은 대처를 할 것을 예상한다.)

GUI 시스템에서는 팝업 윈도우가 사용자에게 오류를 알리고 지시를 기다린다. 일괄 처리 시스템에서는 명령 해석기가 통상 job 전체를 종료하고 다음 job을 계속한다. 몇몇 다른 시스템에서는 오류가 발생할 경우 특별한 복구 행위를 지시하는 제어 카드를 허용한다. 제어 카드는 일괄 처리의 개념이다.

프로그램이 입력에서 오류를 발견하고 비정상적으로 종료하기를 원하는 경우 프로그램은 오류 수준의 정의를 원할 수도 있다. 보다 높은 수준의 오류 매개변수가 보다 심각한 오류를 표시할 수 있다. 이렇게 함으로써 정상 종료를 수준 0의 오류로 정의하여(C를 배울때 int main 하고 return 0를 했었는데, 이게 이 이유일까?)정상종료와 비정상 종료를 결합시킬 수도 있다. 명령 해석기 혹은 그 다음 프로그램은 이 오류 수준을 사용하여 다음 행동을 자동으로 결정할 수 있다.

* 프로세스 제어

  -끝내기(end), 중지(abort)

  -적재(load), 실행(execute)

  -프로세스 생성, 프로세스 종료

  -프로세스 속성(attributes) 획득, 프로세스 속성(attributes) 설정

  -시간을 기다림

  -사건을 기다림(wait event), 사건을 알림(signal event)

  -메모리 할당 및 자유화

  

* 파일 조작

  -파일 생성, 파일 삭제

  -열기 닫기

  -읽기, 쓰기, 위치변경

  -파일속성 획득 및 설정

  

* 장치 관리

  -장치를 요구(request devices), 장치를 방출(release devices)

  -읽기, 쓰기, 위치 변경

  -장치 속성 획득, 장치 속성 설정

  -장치의 논리적 부착(attach) 또는 분리(detach)

  

* 정보 유지

  -시간과 날짜의 설정과 획득

  -시스템 데이터의 설정과 획득

  -프로세스, 파일, 장치 속성의 획득

  -프로세스, 파일, 장치 속성의 설정

  

* 통신

  -통신 연결의 생성, 제거

  -메시지의 송신, 수신

  -상태 정보 전달

  -원격 장치의 부착 및 분리

  

**시스템 호출의 예**

* 프로세스 제어

  * **Windows**

    CreateProcess()

    ExitProcess()

    WaitForSingleObject()

    

  * **Unix**

    fork()

    exit()

    wait()

  

* 파일 조작

  * **Windows**

    CreateFile()

    ReadFile()

    WriteFile()

    CloseHandle()

    

  * **Unix**

    open()

    read()

    write()

    close()

  

* 장치 조작

  * **Windows**

    SetConsoleMode()

    ReadConsole()

    WriteConsole()

    

  * **Unix**

    ioctl()

    read()

    write()

  

* 정보 유지보수

  * **Windows**

    GetCurrentProcessID()

    SetTimer()

    Sleep()

    

  * **Unix**

    getpid()

    alarm()

    sleep()

  

* 통신

  * **Windows**

    CreatePipe()

    CreateFileMapping()

    MapViewOfFile()

    

  * **Unix**

    pip()

    shmget()

    mmap()

  

* 보호

  * **Windows**

    SetFileSecurity()

    InitializeSecurityDescriptor()

    SetSecurityDescriptorGroup()

    

  * **Unix**

    chmod()

    umask()

    chown()

  

  

한 프로그램을 실행하고 있는 프로세스나 job이 다른 프로그램을 적재하고 실행하기를 원할 수 있다. 이 기능은 명령 해석기가 사용자 명령, 마우스의 클릴 혹은 일괄 처리 명령 등을 통하여 지시된 프로그램을 실행할 수 있게 한다.(그럼 CreateProcess로 한 프로세스를 또 실행 시키는 것인가?) 여기서 한가지 궁금증은 적재된 프로그램이 종료되었을 때 어디로 제어를 돌려 주느냐 하는 것이다. 이 질문은 기존 프로그램이 유실될지, 보관될지, 새로운 프로그램과 병행해 실행을 계속하도록 허용할 것인지 하는 문제들과 관련이 있다.

만약 새로운 프로그램이 종료되었을 때, 제어가 기존 프로그램에 되돌아간다면, 우리는 반드시 기존 프로그램의 메모리 이미지를 보관해야 한다. 따라서 우리는 실질적으로 한 프로그램이 다른 프로그램을 호출하는 기법을 만든 셈이 된다. 두 프로그램이 병행하여 실행되는 경우라면, 우리는 다중 프로그래밍 될 새로운 job이나 프로세스를 생성한 것이다.

종종, 이런 특정 목적을 위한 시스템 호출이 제공된다.(create process, submit job)

만약 우리가 새로운 job이나 프로세스 혹은 job들이나 프로세스들의 집합을 생성한다면, 우리는 그들의 실행을 제어할 수 있어야 한다. 이러한 제어는 job의 우선순위, 최대 허용 실행 시간 등을 포함하여 job 혹은 프로세스의 속성들을 결정하고 재설정 할 수 있는 능력을 필요로 한다.(get process attributes 및 set process attributes) 또한 우리는 새로 생성한 잡이나 프로세스가 잘못되었거나 더 이상 필요 없다면 종료하기를 원할 수 있다.(terminate process)

새로운 잡이나 프로세스를 생성한 후에는 이들의 실행이 끝나기를 기다려야 할 필요가 있을 수 있다. 이 때 기다리기를 할수 있다.(wait time). 그리고 보다 가능성이 큰 경우는(이보다 더 활용성이 좋은? 으로 해석 할 수 있겠다.) 우리가 특정 사건이 일어날 때까지 기다리는 것이다.(wait event) 이러한 경우, 잡이나 프로세스들은 그 사건이 일어나면 신호를 보내야 한다.(signal event). 빈번하게 둘 이상의 프로세스들은 데이터를 공유한다. 공유되는 데이터의 일관성을 보장하기 위해서 운영체제는 종종 프로세스가 공유 데이터를 잠글 수 있는 시스템 호출을 제공한다. 따라서 데이터가 잠겨 있는 동안에는 다른 프로세스의 접근을 막을 수 있게 한다.

(***코틀린에서 동시성 프로그래밍? 할때 자바의 lock을 사용한 적이 있다. 여러 프로그램 또는 멀티 스레드 환경일 때에 lock을 사용해야 한다는 문서를 읽은 적이 있지만, 이해하지 못하고 넘어간 적이 있는데, 위의 내용을 좀더 자세하게 공부하고 이해한다면 내가 지금 만든 어플리케이션에 적용 시켜 봐야 겠다.***)

프로세스와 잡 제어는 너무 많은 측면과 다양성이 있기 때문에 우리는 단일 테스킹 시스템과 다중 태스킹 시스템의 두 예를 사용하여 설명할 것이다. MS-DOS 운영체제는 단일 태스킹 시스템의 예로, 컴퓨터가 시동될 때 호출되는 하나의 명령 해석기를 가진다. 이 운영체제는 단일 태스킹이기 때문에, 하나의 프로그램을 실행하기 위해 간단한 방법을 사용하며, 새로운 프로세스를 생성하지 않는다. MS-DOS느느프로그램을 메모리에 적재하여, 가능한 한 많은 메모리를 프로그램에 제공하기 위해 자신의 대부분을 덮어 쓴다. 이어 MS-DOS는 명령 포인터를 프로그램의 첫 번째 명령으로 설정한다. 그 다음 프로그램이 실행되며 오류가 있을 경우는 트랩이 발생되거나, 종료를 위해 시스템 호출을 실행한다. 어느 경우든 다음에 이용하기 위해 오류코드가 시스템 메모리에 저장된다. 이어 명령 해석기의 덮어 쓰이지 않은 적은 부분이 실행을 재개한다. 실행을 재개할 때의 첫번째 일은 명령 해석기의 나머지를 디스크로부터 다시 적재하는 것이다. 이 일이 실행되면, 명령 해석기는 앞의 오류 코드를 사용자나 다음 프로그램이 이용할 수 있게 해준다.

FreeBSD는 다중 태스킹 시스템이기 때문에 명령 해석기는 다른 프로그램이 실행되는 동안 실행을 계속할 수 있다. 새로운 프로세스를 시작하기 위해 셸은 fork() 시스템 호출을 실행한다.(***Windows 에서 Create process로 대체할 수 있겠다.***) 그런 다음 선택된 프로그램이 exec()(***fork()는 프로세스 복제이지만, exec()는 프로세스 대체라고 한다. 프로세스를 대체하게 되면 전에 있던 프로세스(아마 이 함수를 호출하는 프로세스?)는 멈추게 된다.***)시스템 호출을 통해 메머리에 적재되고, 이어 프로그램이 실행된다. 명령이 내려진 방법에 따라 셸은 프로세스가 종료하기를 기다리거나 또는 "백그라운드"에서 프로세스를 실행한다. 후자의 경우 셸은 바로 또 다른 명령을 요청한다. 프로세스가 백그라운드에서 실행될 때 그 프로세스는 키보드로부터 직접 입력받을 수 없는데, 이는 셸이 그 자원을 사용하고 있기 때문이다.(***한마디로 윈도우 창에서 셸을 클릭하고 키보드를 치면 그 키보드 입력은 내가 최소화 해놓은 프로그램에 들어가지 않는다.***)따라서 입출력은 파일, 또는 GUI 인터페이스를 통해서 행해진다. 반면에 사용자는 셸에게 다른 프로그램을 실행하도록 요청하거나, 실행중인 프로세스의 진행 사항을 감시하게 하거나, 그 프로그램의 우선순위를 변경하는 등의 요청을 자유롭게 할 수 있다. 프로세스가 끝나면 종료하기 위해 exit() 시스템 호출을 실행하며,(***쉘 끌때도 exit하면 꺼지던데, 그게 쉘의 프로세스를 종료하는 건가 보다.***) 호출한 프로세스에게 상태 코드 0을 돌려주거나(***C return 0***) 0이 아닌 오류코드를 돌려준다. 이러한 상태 또는 오류코드는 셸 또는 다른 프로그램들이 이용할 수 있게 된다.(***오류의 대응을 프로그램이?***) 프로세스는 fork()와 exec() 시스템 호출을 사용하는 예제 프로그램과 함꼐 3장에서 논의한다.

### 2.4.2 파일 관리

파일을 다루는 몇 개의 공통적인 시스템 호출을 살펴보자(자세한건 다음에)

우리는 파일을 생성하고 삭제할 수 있어야 한다. 이들 시스템 호출은 파일 이름이나 파일 속성의 일부를 요구한다. 파일이 생성되면 그것을 열고 사용해야 한다. 또한 읽고, 쓰고, 그리고 위치변경(되감기, 파일 끝으로 건너뛰기)할 수 있다. 마지막으로 파일을 더 이상 사용하지 않음을 나타내는 파일 닫기가 필요하다.

파일 시스템이 파일을 조작하기 위해 디렉터리 구조를 가진다면, 우리는 디렉터리에 대해서도 이와 같은 연산 집합이 필요할 것이다. 파일이나 디렉터리에 대해 여러 속성의 값(***정렬 같은거?***)을 결정할 수 있어야 하고, 필요하다면 그것을 재설정 할 수 있어야 한다. 파일 속성은 파일 이름, 파일 타입, 보호 코드, 회계 정보 등을 포함한다. 이러한 기능을 위해서는 최소한 파일 속성 획득(get file attrivute)과 파일 속성 설정(set file attribute)의 두 시스템 호출이 필요하다. 몇몇 운영체제는 파일 이동과 복사 등의 훨씬 더 많은 시스템 호출들을 제공한다. 일부 시스템들은 코드와 다른 시스템 호출을 이용하여 동일한 작업을 실행하는 API를 제공할 수도 있고, 일부 시스템은 단순히 동일한 작업을 실행하는 시스템 프로그램을 제공하기도 한다.

### 2.4.3 장치 관리

프로세스는 작업을 계속 실행하기 위해 추가 자원을 필요로 할 수 있다.(***새로운 메모리 할당?***) 이러한 추가 자원은 주 기억장치, 디스크 드라이브, 파일에 접근 등이 될 수 있다. 자원을 줄 수 있다면 자원을 주고, 제어가 사용자 프로그램으로 복귀될 수 있다. 만약 자원이 없다면, 프로세스는 자원 사용이 가능해 질 때까지 기다려야 한다.

장치는 두가지 경우로 생각할수 있다. 물리장치(디스크, 모니터 등)와 가상 장치(파일)이다. 다수의 사용자가 동시에 사용하는 시스템은 장치를 한 사람이 독점적으로 사용할 수 있어야 한다.(동시에 접근할 수 없다.) 따라서 반드시 request를 해서 사용중이지 않을 때 사용을 하고, 사용이 끝나면 방출, release를 해야 한다. 이런 기능은 파일 열기 닫기 open close 시스템 호출과 비슷하다. 입출력 장치와 파일들에는 유사성이 많기 때문에 UNIX를 포함한 많은 운영체제가 이들 둘을 통합된 파일-장치 구조로 결합하였다. 이런 구조에서는 같은 시스템 호출 명령으로 파일과 장치에 대해 사용된다.

### 2.4.4 정보의 유지

많은 시스템 호출은 사용자 프로그램과 운영체제간의 정보 전달을 위해 존재한다. 예를 들어 현재 사용자 수, 운영체제의 버전 번호, 자유메모리 또는 자유 디스크 공간, 현재 시간과 날짜를 되돌려 주는 시스템 호출 등이 있다.

다른 시스템 호출들은 프로그램을 디버깅할 때 유용한 호출들이 있다. 많은 시스템들은 메모리를 덤프 하기 위한 시스템 호출을 제공하고,소수의 시스템이지만 각 명령어가 실행될 때 이들을 하나씩 나열하는 프로그램 추적 시스템 호출을 제공하기도 한다. 마이크로 프로세서들도 단일 단계라고 하는 CPU모드를 제공하는데, 하나의 명령어 마다 실행후 트랩을 걸어 디버거에 포착되게 하는 모드가 있다.

많은 운영체제는 프로그램의 시간 프로파일을 제공한다. 이 기능은 그 프로그램이 특정 위치 혹은 위치의 집합에서 실행한 시간의 양을 나타낸다. 시간 프로파일은 tracing facility나 정규 타이머 인터럽트를 필요로 한다. 타이머 인터럽트가 발생할 때마다 프로그램 카운터의 값이 기록된다. 따라서 빈번하게 타이머 인터럽트가 발생하면, 프로그램의 여러 부분에서 소비한 시간을 통계하여 그림을 얻을 수 있다.

### 2.4.5 통신



