## 2.4 시스템 호출의 유형

시스템 호출은 프로세스 제어, 파일 조작, 장치 조작, 정보 유지 보수와 통신과 보호 등 다섯가지의 중요한 범주로 묶을 수 있다. 이 다섯가지를 간단히 살펴 보자.

### 2.4.1 프로세스 제어

실행중인 프로그램은 실행을 정상적, 또는 비정상적으로 끝낼 수 있어야 한다. 만약 실행중인 프로그램을 비정상 적으로 중지하기 위해 시스템 호출을 하거나 프로그램에 문제가 발생해 트랩을 유발할 경우 때때로 메모리 덤프가 행해지고 오류 메시지가 생성된다. 이 덤프는 디스크에 기록되고 문제의 원인을 결정하기 위해 디버거에 의해 검사될 수 있다. 

정상적, 비정상적인 상황에서 운영체제는 명령 해석기로 제어를 전달해야 한다. 명령 해석기는 이어 다음 명령을 읽는다. 대화식 시스템에서 명령 해석기는 단순히 다음 명령을 계속 실행하며, 사용자가 오류에 응답하는 적절한 명령을 내릴 것을 가정한다.(명령 해석기는 사용자가 오류에 대해 인지하고 그에 대한 해결책 혹은 대처를 할 것을 예상한다.)

GUI 시스템에서는 팝업 윈도우가 사용자에게 오류를 알리고 지시를 기다린다. 일괄 처리 시스템에서는 명령 해석기가 통상 job 전체를 종료하고 다음 job을 계속한다. 몇몇 다른 시스템에서는 오류가 발생할 경우 특별한 복구 행위를 지시하는 제어 카드를 허용한다. 제어 카드는 일괄 처리의 개념이다.

프로그램이 입력에서 오류를 발견하고 비정상적으로 종료하기를 원하는 경우 프로그램은 오류 수준의 정의를 원할 수도 있다. 보다 높은 수준의 오류 매개변수가 보다 심각한 오류를 표시할 수 있다. 이렇게 함으로써 정상 종료를 수준 0의 오류로 정의하여(C를 배울때 int main 하고 return 0를 했었는데, 이게 이 이유일까?)정상종료와 비정상 종료를 결합시킬 수도 있다. 명령 해석기 혹은 그 다음 프로그램은 이 오류 수준을 사용하여 다음 행동을 자동으로 결정할 수 있다.

* 프로세스 제어

  -끝내기(end), 중지(abort)

  -적재(load), 실행(execute)

  -프로세스 생성, 프로세스 종료

  -프로세스 속성(attributes) 획득, 프로세스 속성(attributes) 설정

  -시간을 기다림

  -사건을 기다림(wait event), 사건을 알림(signal event)

  -메모리 할당 및 자유화

  

* 파일 조작

  -파일 생성, 파일 삭제

  -열기 닫기

  -읽기, 쓰기, 위치변경

  -파일속성 획득 및 설정

  

* 장치 관리

  -장치를 요구(request devices), 장치를 방출(release devices)

  -읽기, 쓰기, 위치 변경

  -장치 속성 획득, 장치 속성 설정

  -장치의 논리적 부착(attach) 또는 분리(detach)

  

* 정보 유지

  -시간과 날짜의 설정과 획득

  -시스템 데이터의 설정과 획득

  -프로세스, 파일, 장치 속성의 획득

  -프로세스, 파일, 장치 속성의 설정

  

* 통신

  -통신 연결의 생성, 제거

  -메시지의 송신, 수신

  -상태 정보 전달

  -원격 장치의 부착 및 분리

  

**시스템 호출의 예**

* 프로세스 제어

  * **Windows**

    CreateProcess()

    ExitProcess()

    WaitForSingleObject()

    

  * **Unix**

    fork()

    exit()

    wait()

  

* 파일 조작

  * **Windows**

    CreateFile()

    ReadFile()

    WriteFile()

    CloseHandle()

    

  * **Unix**

    open()

    read()

    write()

    close()

  

* 장치 조작

  * **Windows**

    SetConsoleMode()

    ReadConsole()

    WriteConsole()

    

  * **Unix**

    ioctl()

    read()

    write()

  

* 정보 유지보수

  * **Windows**

    GetCurrentProcessID()

    SetTimer()

    Sleep()

    

  * **Unix**

    getpid()

    alarm()

    sleep()

  

* 통신

  * **Windows**

    CreatePipe()

    CreateFileMapping()

    MapViewOfFile()

    

  * **Unix**

    pip()

    shmget()

    mmap()

  

* 보호

  * **Windows**

    SetFileSecurity()

    InitializeSecurityDescriptor()

    SetSecurityDescriptorGroup()

    

  * **Unix**

    chmod()

    umask()

    chown()

  

  

한 프로그램을 실행하고 있는 프로세스나 job이 다른 프로그램을 적재하고 실행하기를 원할 수 있다. 이 기능은 명령 해석기가 사용자 명령, 마우스의 클릴 혹은 일괄 처리 명령 등을 통하여 지시된 프로그램을 실행할 수 있게 한다.(그럼 CreateProcess로 한 프로세스를 또 실행 시키는 것인가?) 여기서 한가지 궁금증은 적재된 프로그램이 종료되었을 때 어디로 제어를 돌려 주느냐 하는 것이다. 이 질문은 기존 프로그램이 유실될지, 보관될지, 새로운 프로그램과 병행해 실행을 계속하도록 허용할 것인지 하는 문제들과 관련이 있다.

만약 새로운 프로그램이 종료되었을 때, 제어가 기존 프로그램에 되돌아간다면, 우리는 반드시 기존 프로그램의 메모리 이미지를 보관해야 한다. 따라서 우리는 실질적으로 한 프로그램이 다른 프로그램을 호출하는 기법을 만든 셈이 된다. 두 프로그램이 병행하여 실행되는 경우라면, 우리는 다중 프로그래밍 될 새로운 job이나 프로세스를 생성한 것이다.

종종, 이런 특정 목적을 위한 시스템 호출이 제공된다.(create process, submit job)

만약 우리가 새로운 job이나 프로세스 혹은 job들이나 프로세스들의 집합을 생성한다면, 우리는 그들의 실행을 제어할 수 있어야 한다. 이러한 제어는 job의 우선순위, 최대 허용 실행 시간 등을 포함하여 job 혹은 프로세스의 속성들을 결정하고 재설정 할 수 있는 능력을 필요로 한다.(get process attributes 및 set process attributes) 또한 우리는 새로 생성한 잡이나 프로세스가 잘못되었거나 더 이상 필요 없다면 종료하기를 원할 수 있다.(terminate process)

새로운 잡이나 프로세스를 생성한 후에는 이들의 실행이 끝나기를 기다려야 할 필요가 있을 수 있다. 이 때 기다리기를 할수 있다.(wait time). 그리고 보다 가능성이 큰 경우는(이보다 더 활용성이 좋은? 으로 해석 할 수 있겠다.) 우리가 특정 사건이 일어날 때까지 기다리는 것이다.(wait event) 이러한 경우, 잡이나 프로세스들은 그 사건이 일어나면 신호를 보내야 한다.(signal event). 빈번하게 둘 이상의 프로세스들은 데이터를 공유한다. 공유되는 데이터의 일관성을 보장하기 위해서 운영체제는 종종 프로세스가 공유 데이터를 잠글 수 있는 시스템 호출을 제공한다. 따라서 데이터가 잠겨 있는 동안에는 다른 프로세스의 접근을 막을 수 있게 한다.

(코틀린에서 동시성 프로그래밍? 할때 자바의 lock을 사용한 적이 있다. 여러 프로그램 또는 멀티 스레드 환경일 때에 lock을 사용해야 한다는 문서를 읽은 적이 있지만, 이해하지 못하고 넘어간 적이 있는데, 위의 내용을 좀더 자세하게 공부하고 이해한다면 내가 지금 만든 어플리케이션에 적용 시켜 봐야 겠다.)

프로세스와 잡 제어는 너무 많은 측면과 다양성이 있기 때문에 우리는 단일 테스킹 시스템과 다중 태스킹 시스템의 두 예를 사용하여 설명할 것이다. MS-DOS 운영체제는 단일 태스킹 시스템의 예로, 컴퓨터가 시동될 때 호출되는 하나의 명령 해석기를 가진다. 이 운영체제는 단일 태스킹이기 때문에, 하나의 프로그램을 실행하기 위해 간단한 방법을 사용하며, 새로운 프로세스를 생성하지 않는다. MS-DOS느느프로그램을 메모리에 적재하여, 가능한 한 많은 메모리를 프로그램에 제공하기 위해 자신의 대부분을 덮어 쓴다. 이어 MS-DOS는 명령 포인터를 프로그램의 첫 번째 명령으로 설정한다.
