## 1.8 저장장치 관리

운영체제는 저장장치의 물리적 특성(자기로 저장되는 HDD 특성)을 추상화하여 논리적인 저장 단위인 **파일**을 정의한다. 운영체제는 파일을 물리적 매체로 사상하며, 저장장치를 통해 이들 파일에 접근한다.

### 1.8.1 파일 시스템 관리

컴퓨터는 여러 타입의 물리적 매체에 정보를 저장할 수 있다. 자기테이프(비디오 테이프), 자기디스크(플로피 디스크, HDD), 광디스크(CD, DVD) 등이 가장 일반적인 메체들이다.

파일은 파일 생성자에 의해 정의된 관련 정보의 집합체이다. 일반적으로 파일은 프로그램과 데이터를 나타낸다. 데이터 파일은 숫자, 영문자, 영숫자 등으로 구성된다. 파일은 텍스트 파일과 같은 자유 형태일 수 있고, 엄격하게 포멧된 형태일 수도 있다.(Json 같은걸 얘기하는 것인가?) 파일은 비트, 바이트, 줄, 또는 레코드들의 연속으로 구성되며, 이들의 의미는 파일 생성자에 의해 정의된다.

운영체제는 테이프와 디스크 같은 대량 저장매체와 그것을 제어하는 장치를 관리함으로써 파일의 추상적인 개념을 구현한다.

운영체제는 파일 관리를 위하여 다음과 같은 일을 담당한다.

* 파일의 생성 및 제거
* 디렉터리 생성 및 제거
* 파일과 디렉터리를 조작하기 위한 프리미티브(원시적인 이란 뜻으로, 가장 기본이 되는 이용가능한 작은 처리 등을 나타낸다고 한다. 원자)의 제공
* 파일을 보조 저장장치로 맵핑
* 비휘발성 저장메체(HDD,SSD)에 파일을 백업

### 1.8.2 대용량 저장장치 관리

주 메모리(RAM)은 모든 데이터와 프로그램을 수용하기에는 용량이 너무 작고, 휘발성이기 때문에 컴퓨터 시스템은 디스크를 프로그램과 데이터를 위한 주된 온라인 저장매체로 사용하고 있다. 대부분의 프로그램은 주 메모리에 적재된 때까지 디스크에 저장되며, 그들이 처리할 데이터의 출발지와 목적지(도착지)로서 디스크를 사용하고 있다.(디스크에서 램으로 가져와서 데이터를 실행, 수정, 생성한 후 다시 디스크로) 운영체제는 디스크 관리를 위하여 다음과 같은 기능을 담당한다.

* 자유 공간의 관리
* 저장 장소 할당
* 디스크 스케줄링

보조 저장장치는 매우 빈번하게 사용되므로, 효율적으로 사용해야 한다. 컴퓨토의 전체 동작 속도는 디스크 서브시스템과 그것을 조작하는 알고리즘의 속도에 의해 결정될 수 있다.(전 챕터에서는 심지어 이 시간이 너무 길어 다중 프로그래밍의 기준이 되었었다.)

### 1.8.3 캐싱

**캐싱**은 컴퓨터 시스템의 중요한 원리이다. 정보는 저장장치에 보관되는데, 정보가 사용됨에 다라 보다 빠른 장치인 캐시에 일시적으로 복사된다. 그러므로, 정보가 필요할 경우 그 정보가 캐시에 있는지 먼저 보아야 한다. 만약 캐시에 없다며 주 메모리 시스템으로부터 그 정보를 가져와서 사용해야 하며, 이 때, 이 정보가 다음에 곧 다시 사용될 확률이 높다는 가정 하에 캐시에 넣는다.

CPU 레지스터들은 주 메모리를 위한 고속의 캐시로 볼 수 있다. 프로그래머 또는 컴파일러는 어느 정보를 주 메모리에 두고, 어느 정보를 레지스터에 둘 것인지를 결정하는 정책과 교체 알고리즘을 구현한다. 전적으로 하드웨어로 구현된(프로그래밍한 것이 아니라) 캐시도 있지만, 이는 운영체제가 관리 할 수 없기 때문에 이 곳에서는 설명하지 않는다.

(참고로 레지스터란, 내가 아는 그 저항이 아니다. 레지스터는 CPU가 가장 고속으로 접근할 수 있는 저장장치이자, 컴퓨터 저장장치중 가장 최상위 저장장치이다.)

캐시는 크기는 한계가 있기 때문에, 캐시의 크기와 교체 정책을 잘 선택하면 매우 높은 성능향상을 기대할 수 있다.

주 메모리는 보조 메모리(HDD)를 위한 빠른 캐시로 볼 수 있는데, 레지스터와 마찬가지의 이유로 볼 수 있다. 파일 시스템 데이터는 저장장치 계층의 여러 단계에 존재할 수 있다.(참고로 캐시가 실제 CPU내 또는 가까이에 위치한 메모리이며, 레지스터는 CPU가 계산을 위해 데이터를 저장하는 공간으로, RAM과 레지스터 간의 속도 차를 매꾸기 위한 중간단계 메모리이다.)

저장장치의 계층구조에서 각 수준간의 정보 이동은 하드웨어 설계나 제어하는 운영체제에 따라 명시적 또는 묵시적으로 이루어진다. 예를 들어, 캐시로부터 CPU및 레지스터로의 데이터 전송은 통상 운영체제의 간섭 없이 하드웨어적으로 이루어진다.(캐시까지만 신경써서 운영체제를 만들면 된다는 뜻) 반면 디스크와 메모리간의 데이터 전송은 통상 운영체제에 의해 제어된다.

**중요!**

메모리 계층 구조에서 동일한 데이터가 동시에 서로 다른 수준의 저장장치 시스템에 나타나게 된다. 예를들어, B라는 파일에 있는 A라는 변수가 1 증가해야 된다고 가정했을 때, 파일 B가 자기 디스크에 있다면 증가영산은 먼저 A가 있는 디스크 블록(파일의 일부분?)을 주 메모리로 복사해오는 입출력 연산을 호출함으로써 진행된다. 이어서 A를 캐시에 복사, 그후 다시 내부 레지스터로 복사한다. 이렇게 되면 A의 복사본이 각각 여러곳에 존재하는데, 내부 레지스터에서 증가가 일어나면 A의 값은 여러 저장장치 시스템에서 서로 달라지게 된다. 다시 반대의 과정을 거쳐 자기 디스크로 저장되야 비로소 같아진다.

어떤 시간에 단지 하나의 프로세스만 실행하는 환경에서는 이러한 기법이 문제가 없다. 정수 A에 대한 접근은 항상 계층 구조의 최상위 값을 참조하기 때문이다. 그러나 여러개의 프로세스들이 전환되는 멀티테스킹의 환경에서는 여러개의 프로세스가 A에 접간히기를 원할 경우, 이들 각 프로세스가 가장 최근에 갱신된 A의 값을 얻는 것을 보장하기 위해서는 매우 주의를 기울여야 한다.

로컬캐시를 각각 갖고 있는 다중처리기 환경에서는 더욱 복잡해진다. 이 때는 A의 복사본이 동시에 여러 캐시에 존재할 수도 있다. 한 캐시에 있는 A 값이 갱신되면, A가 존재하는 모든 캐시에 즉각적으로 반영되어야 한다. 이런 상황을 **캐시 일관성 문제**라고 하며, 일반적으로 하드웨어적 문제이다.

(요즘의 CPU는 모두 멀티코어이다. 아마 이 책에서 말하는 다중처리기 환경일 것이다. 따라서 이러한 일들이 항상 일어난다고 봐도 무방할 것 같다. 이러한 문제는 하드웨어적 문제라고는 하지만 운영체제를 만들 때에 고려해야 할 상황인것 같다.)

### 1.8.4 입출력 시스템

운영체제의 목적 중의 하나는 사용자에게 특정 하드웨어 장치의 특성을 숨기는 것이다.(사용자가 알지 못해도 사용 가능한 이유) 예를들면 UNIX에서 입출력 장치의 특성은 입출력 서브시스템에 의해 운영체제 자체의 나머지 부분으로 숨겨져 있다. 입출력 시스템은 다음과 같이 구성되어 있다.

* 버퍼링, 캐싱, 스풀링을 포함한 메모리 관리 구성요소
* 일반적인 장치 드라이버 인터페이스
* 특정 하드웨어 장치들을 위한 드라이버

오직 장치 드라이버만이 자신에게 지정된 특정 장치의 특성을 알고 있다.



### 완전 압축 정리

운영체제는 저장장치의 물리적 특성을 논리적으로 변환하여 파일을 정의한다.

캐싱은 매우 중요한것 같다.(사실 평소에 궁금해 하던 것들이다.) 전체 다 천천히 읽어보자.

오직 드라이버만이 자신에게 지정된 특정 장치의 특성을 알고 있다. 따라서 특정 하드웨어 장치의 특성을 숨길 수 있다.

