## 1.5 운영체제 동작

현대의 운영체제는 인터럽트 이동식이다. 실행할 프로세스가 없고, 서비스할 입출력장치도 없고, 응답해 주어야 할 사용자도 없다면, 운영체제는 무엇인가 일어나기를 기다리며 가만히 있는다. 사건은 거의 항상 인터럽트나 트랩을 발생시켜 신호를 보낸다. 트랩은 오류(파이썬 할 때 divide by 0 같은거.)또는 프로그램이 사용자의 요청으로 발생시키는 인터럽트이다. 각 타입의 인터럽트에 대해 어떠한 행동을 취해야 할지는 운영체제 내의 서로 다른 코드 세그먼트가 결정한다. 하나의 인터럽트를 처리하기 위해 하나의 인터럽트 서비스 루틴이 제공된다.

운영체제와 사용자는 컴퓨터 시스템의 하드웨어와 소프트웨어 자원을 공유하기 때문에 사용자 프로그램의 오류가 그 오류가 다른 프로그램에 문제를 일으키지 않음을 보장해야 한다. 자원 공유 때문에 한 프로그램의 버그로 다른 프로그램들이 악영향을 받을 수 있다.(C 포인터에 임의의 변수를 넣고 그 데이터를 바꾼다고 생각해 보자... 끔찍하다.) 예를 들면, 하나의 프로세스가 무한루프에 빠진다면 다른 프로세스의 정상적인 동작을 방해할 수 있다.(입출력때 다른 프로세스를 실행시킨다고 했으니까 무한루프가 일어나면 다른 프로세스로의 작업 이동이 일어나지 않을 것 같다.) 이러한 종류의 오류에 대한 보호 기능이 없으면 컴퓨터 시스템은 한 순간에 단 하나의 프로세스만을 실행시키거나 모든 출력 결과를 의심할 수밖에 없다.

### 1.5.1 이중 동작 모드

운영체제의 적절한 동작을 보장하기 위해 운영체제 코드의 실행과 사용자 정의 코드의 실행을 구분할 수 있어야 한다. 이중 가장 많이 사용되는 방식은 여러 실행 모드를 구분할 수 있도록 지원하는 하드웨어를 이용하는 것이다. 동작에는 적어도 두 개의 동작이 필요한데, **사용자 모드**와 **커널 모드**(또는 슈퍼바이저 모드, 시스템 모드, 특권 모드 라고 한다.) 하드웨어에는 **모드 비트** 라고 하는 것이 있는데, 이 비트가 0일 경우에는 커널모드, 1일 경우에는 사용자 모드를 나타낸다. 이로서 사용자의 실행 작업과 운영체제의 실행 작업을 구분할 수 있다.

처음 부팅 시에는 커널 모드로 시작한다. 이 시점에서 운영체제가 메모리에 적재되고, 사용자 모드에서 사용자 프로세스가 시작된다. 트랩이나 인터럽트가 발생하면 하드웨어는 사용자 모드에서 커널 모드로 전환한다. 시스템은 사용자 프로그램으로 제어를 넘기기 전에 항상 사용자 모드로 모드 비트를 1로 전환한다.

**특권 명령**이라고 시스템에 악 영향을 끼칠 수 있는 일부 명령이 있는데, 하드웨어는 특권 명령이 커널 모드에서만 실행되도록 한다. 사용자 모드에서 특권 명령을 하려고 하면  하드웨어는 불법적인 명령으로 간주해 운영체제로 트랩을 건다. 커널모드 변경이 특권 명령의 한 예이다. 또다른 것으로는 입출력 제어, 타이머 관리, 인터럽트 관리 명령어 들이 있다.

![image-20211003031422942](C:\Users\moony\AppData\Roaming\Typora\typora-user-images\image-20211003031422942.png)

시스템 호출은 사용자 프로그램이 자신을 대신하여 운영체제가 실행하도록 미리 지정되어 있는 작업들을 운영체제에게 요청할 수 있는 방법을 제공한다. 시스템 호출은 운영체제에 의해 실행될 동작을 사용자 프로세스가 요청할 수 있게 한다.(백그라운드 스레드?)

시스템 호출은 하나의 소프트웨어 인터럽트로 취급된다. 시스템 호출 서비스 루틴은 운영체제의 일부인데, 제어가 인터럽트 백터를 통해 운영체제 내의 서비스 루틴으로 전달되고, 모드 비트가 커널 모드로 설정된다. 커널은 인터럽트를 발생시킨 명령을 검사하여 어떤 시스템 호출이 발생했는지를 결정한다. 이때 전달된 인자가 사용자 프로그램이 요청하는 서비스 타입을 표시한다.

하드웨어가 지원하는 이중 모드가 없을 경우는 운영체제에 심각한 결점을 초래할 수 있다. 잘못하면 운영체제를 지워버릴 수 있고, 여러 프로그램이 동시에 한 장치에 기록할 수 있어 잘못된 결과가 발생할 수 있다.

하드웨어 보호 기능이 제공되면 하드웨어는 모드 규칙을 위반하는 오류를 탐지한다. 이러한 오류는 운영체제가 처리하는데, 사용자 프로그램이 불법적인 명령을 실행하거나, 사용자 주소 공간이 아닌 메모리에 접근하는 등과 같은 오류가 발생하면, 하드웨어는 운영체제로 트랩을 발생시킨다.(하드웨어가 오류를 잡는 거였다고...?)트랩은 인터럽트처럼 인터럽트 벡터를 통해 제어를 운영체제에게 넘긴다. 프로그램 오류가 발생할 때마다 운영체제는 비정상적으로 프로그램을 종료시킨다.

### 1.5.2 타이머

운영체제는 CPU에 대한 제어를 유지해야 한다. 사용자의 프로그램이 무한루프에 걸리거나, 시스템 서비스를 호출하지 않아서(모드 비트 변경?) 제어가 운영체제로 복귀하지 않는 경우를 허용할 수 없다.이를 해결하기 위해서 **타이머**를 사용할 수 있다. 타이머는 지정된 시간 후 컴퓨터를 인터럽트하도록 설정할 수 있다. 이 시간은 고정 혹은 가변일 수 있다. 

(가변타이머는 계수기로 구현하는데, 계수기는 단위 시간과 계수기 값이 있다. 단위 시간마다 인터럽트를 하고, 인터럽트가 나오면 계수기 값을 1씩 감소 시킨다. 계수기 값이 양수면 다시 프로그램으로 돌아가고, 음수면 프로그램을 종료한다. 따라서 타이머 동작을 할 수 있다. 계수기 값은 운영체제가 정한다.)

사용자에게 제어를 양도하기 전에 운영체제는 타이머에 인터럽트가 설정 되었는지를 확인한다. 타이머가 인터럽트를 발생시키면 제어는 자동적으로 운영체제로 넘어가며, 운영체제는 인터럽트를 치명적인 오류로 취급하거나 프로그램에게 더 많은 시간을 줄 수 있다. 타이머의 동작을 변경하는 명령은 특권 명령이다.

###  완전 압축 요약

CPU에는 사용자 모드(1)와 커널모드(0)을 나타내는 모드 비트가 있다.

트랩이나 인터럽트, 특권 명령 등을 받으면 CPU는 사용자 모드로 바꾼 후, 그 요청을 실행할지 안할지 판단한다.

타이머란 사용자 프로그램의 무한 루프등으로 운영체제로 제어가 오지 않을 경우를 대비해 만들어진 기능이다. 시간 내에 돌아오지 않으면 강제 종료한다.





