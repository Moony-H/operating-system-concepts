## 1.5 운영체제 동작

현대의 운영체제는 인터럽트 이동식이다. 실행할 프로세스가 없고, 서비스할 입출력장치도 없고, 응답해 주어야 할 사용자도 없다면, 운영체제는 무엇인가 일어나기를 기다리며 가만히 있는다. 사건은 거의 항상 인터럽트나 트랩을 발생시켜 신호를 보낸다. 트랩은 오류(파이썬 할 때 divide by 0 같은거.)또는 프로그램이 사용자의 요청으로 발생시키는 인터럽트이다. 각 타입의 인터럽트에 대해 어떠한 행동을 취해야 할지는 운영체제 내의 서로 다른 코드 세그먼트가 결정한다. 하나의 인터럽트를 처리하기 위해 하나의 인터럽트 서비스 루틴이 제공된다.

운영체제와 사용자는 컴퓨터 시스템의 하드웨어와 소프트웨어 자원을 공유하기 때문에 사용자 프로그램의 오류가 그 오류가 다른 프로그램에 문제를 일으키지 않음을 보장해야 한다. 자원 공유 때문에 한 프로그램의 버그로 다른 프로그램들이 악영향을 받을 수 있다.(C 포인터에 임의의 변수를 넣고 그 데이터를 바꾼다고 생각해 보자... 끔찍하다.) 예를 들면, 하나의 프로세스가 무한루프에 빠진다면 다른 프로세스의 정상적인 동작을 방해할 수 있다.(입출력때 다른 프로세스를 실행시킨다고 했으니까 무한루프가 일어나면 다른 프로세스로의 작업 이동이 일어나지 않을 것 같다.) 이러한 종류의 오류에 대한 보호 기능이 없으면 컴퓨터 시스템은 한 순간에 단 하나의 프로세스만을 실행시키거나 모든 출력 결과를 의심할 수밖에 없다.

### 1.5.1 이중 동작 모드

운영체제의 적절한 동작을 보장하기 위해 운영체제 코드의 실행과 사용자 정의 코드의 실행을 구분할 수 있어야 한다. 이중 가장 많이 사용되는 방식은 여러 실행 모드를 구분할 수 있도록 지원하는 하드웨어를 이용하는 것이다. 동작에는 적어도 두 개의 동작이 필요한데, **사용자 모드**와 **커널 모드**(또는 슈퍼바이저 모드, 시스템 모드, 특권 모드 라고 한다.) 하드웨어에는 **모드 비트** 라고 하는 것이 있는데, 이 비트가 0일 경우에는 커널모드, 1일 경우에는 사용자 모드를 나타낸다. 이로서 사용자의 실행 작업과 운영체제의 실행 작업을 구분할 수 있다.

처음 부팅 시에는 커널 모드로 시작한다. 이 시점에서 운영체제가 메모리에 적재되고, 사용자 모드에서 사용자 프로세스가 시작된다. 트랩이나 인터럽트가 발생하면 하드웨어는 사용자 모드에서 커널 모드로 전환한다. 시스템은 사용자 프로그램으로 제어를 넘기기 전에 항상 사용자 모드로 모드 비트를 1로 전환한다.

특권 명령이라고 시스템에 악 영향을 끼칠 수 있는 일부 명령이 있는데, 하드웨어는 특권 명령이 커널 모드에서만 실행되도록 한다. 사용자 모드에서 특권 명령을 하려고 하면  하드웨어는 불법적인 명령으로 간주해 운영체제로 트랩을 건다. 커널모드 변경이 특권 명령의 한 예이다. 또다른 것으로는 입출력 제어, 타이머 관리, 인터럽트 관리 명령어 들이 있다.

![image-20211003031422942](C:\Users\moony\AppData\Roaming\Typora\typora-user-images\image-20211003031422942.png)

시스템 호출은 사용자 프로그램이 자신을 대신하여 운영체제가 실행하도록 미리 지정되어 있는 작업들을 운영체제에게 요청할 수 있는 방법을 제공한다. 시스템 호출은 운영체제에 의해 실행될 동작을 사용자 프로세스가 요철할 수 있게 한다.(백그라운드 스레드?)

시스템 호출은 하나의 소프트웨어 인터럽트로 취급된다.  제어가 인터럽트 백터를 통해 운영체제 내의 서비스 루틴으로 전달되고, 모드 비트가 커널 모드로 설정된다.

