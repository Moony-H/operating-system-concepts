### 1.2 컴퓨터 시스템의 구성

-------



### 1.2.1 컴퓨터 시스템 동작

현대의 컴퓨터 시스템은 공유 메모리에 대한 접근을 제공하는 공통 버스(아마 금색 줄?)를 통해 연결된 여러개의 장치 제어기와 하나 이상의 CPU로 구성되어 있다.

CPU는 제어기가 없고, 디스크는 디스크 제어기, 마우스와 키보드 등등은 USB 제어기, 모니터는 그래픽 어댑터(내 컴퓨터는 GPU에 연결되어 있는데, 아마 GPU가 대신하지 않을까.)를 통해 메모리에 접근한다. 이러한 제어기를 통틀어 **장치 제어기** 라고 한다.

CPU와 장치 제어기는 메모리 사이클을 얻기 위해 경쟁하면서, 병행 실행될 수 있다. 공유 메모리에 대한 질서있는 접근을 보장하기 위해 메모리 제어기가 제공되며, 메모리 제어기의 기능은 메모리 접근을 동기화 시키는 일이다.

컴퓨터가 구동을 하기 위해서는 실행할 초기 프로그램이 필요하다. 이것을 부트스트랩(Bootstrap program)이라 하는데, 이러한 프로그램은 매우 단순한 형태를 가진다. 보통 펌웨어라고 알려져 있는 컴퓨터 내의 **읽기 전용 메모리**(Read Only Memory,**ROM**이다.) 에 저장된다.

(검색한 바로, 옛날 컴퓨터는 데이터를 저장하고 읽는게 굉장히 힘들었다고 한다. 한번 데이터를 쓰면 바꾸지 못했다고. 거의 하드디스크와 ssd가 없던 시절? 그래서 읽기전용 메모리인 ROM과, 저장이 불가능하지만 읽고 쓰기가 가능했던 휘발성 메모리 RAM 밖에 없는 수준인데, ROM에 컴퓨터를 부팅할 수 있는 프로그램을 깔고, 램으로 계산을 돌린 것 같다. 요즘 윈도우를 SSD나 HDD에 까는 것을 보면, 바이오스가 이걸 대신하는것이 아닐까?)

이것은 CPU 레지스터로부터 장치 제어기, 메모리 내용 등을 포함한 시스템의 모든 면을 초기화한다.  또한 부트스트랩 프로그램은 운영체제의 커널을 찾아 메모리에 적재해야 한다.(운영체제를 어디다 깔았다고 알려주지 않아도 알아서 찾는 이유가 이녀셕 때문이었구나.) 그런다음 운영체제는 init과 같은 첫번째 프로세스를 실행하고 어떤 사건이 발생하기를 기다린다.



**인터럽트**

사건이 발생하면 하드웨어나 또는 소프트웨어로부터 발생한 인터럽트(Interrupt)에 의해 신호가 보내어진다. 하드웨어는 어느 순간이든 시스템 버스를 통해 CPU에 신호를 보내 인터럽트를 발생시킬 수 있다. (아두이노에도 있는데, 아두이노에서는 고정된 핀인 interrupt pin으로 신호가 들어오면 주로 하던 작업을 중간에 멈추고, 원하는 기능을 수행하고 다시 하던 작업으로 돌아가는 기능이었다. PC와 비슷한것 같다.) 하드웨어 뿐만 아니라 소프트웨어도 시스템 호출이라는 특별한 연산을 수행하여 인터럽트를 발생시킬 수 있다.



CPU가 인터럽트 되면, CPU는 하던 일을 중단하고, 즉시 고정된 위치로 실행을 옮긴다. 고정된 위치는 일반적으로 인터럽트를 위한 서비스 루틴이 위치한 시작주소를 가지고 있다. 인터럽트 서비스 루틴의 실행이 완료되면, CPU는 인터럽트 되었던 연산을 재개한다.

인터럽트는 매우 중요하다. 각 컴퓨터는 자신의 인터럽트 메커니즘을 가지고 있으며, 몇가지 기능은 공통적이다. 인터럽트는 적절한 서비스 루틴으로 제어를 전달한다. 이러한 전달을 처리하는 방법에는 인터럽트 정보를 조사하는 일반적인 루틴을 호출하는 방법이다. 이 루틴은 이어 인터럽트 고유의 핸들러를 호출한다. 인터럽트는 매우 빠르게 처리되어야 하고, 사용 가능한 인터럽트의 수가 미리 정의되어 있으므로, 대신 인터럽트 루틴에 대한 포인터들(C?)의 테이블을 이용할 수 있다. 이 경우는 중간에 루틴을 둘 필요 없이 테이블을 통하여 간접적으로 인터럽트 루틴이 호출될 수 있다.

일반적으로 이 포인터 테이블은 하위 메모리에 저장된다. 이 위치에는 여러 장치에 대한 인터럽트 서비스 루틴의 주소가 들었다.

(한마디로 장치의 동시다발적인 요청(인터럽트)을 하나의 CPU에(코어가 하나인) 중요한 순서대로 하나하나 처리하고, 그 처리를 위한 주소값들을 하위 메모리에 저장하면 빠르게 처리가 가능하다는 건가? 딕셔너리의 해시 테이블?)



### 1.2.2 저장장치 구조

CPU는 오직 메모리로부터 명령을 적재할 수 있으며(CPU에 저장할 수 있는 부분을 먼저 이야기 해야 하지 않나? CPU에는 캐시 메모리가 있는 것으로 안다. 혹은 레지스터? 아마 메모리에 있는 명령들을 자신의 캐시 메모리에 적재한다는 뜻 인듯.), 실행하고자 하는 프로그램은 모두 메모리에 저장되어야 한다. 컴퓨터는 대부분의 프로그램을 **RAM**(Random Access Memory)에서 실행 시킨다.

모든 형태의 메모리는 [워드](https://ko.wikipedia.org/wiki/%EC%9B%8C%EB%93%9C_(%EC%BB%B4%ED%93%A8%ED%8C%85))의 배열을 제공하며, 각 워드는 고유의 주소를 가지고 있다. 상호작용은 특정 메모리 주소들에 대한 일련의 적재, 또는 저장 명령을 통하여 이루어 진다. 

적재는 주 메모리로부터 CPU 내부의 레지스터로 한 워드를 옮기는 것이다. 반대로 저장은 레지스터의 내용을 주 메모리로 옮긴다. 명시적인 적재, 저장 명령 외에 CPU는 실행을 위해 자동적으로 주 메모리로부터 명령을 적재한다.

(링크를 걸어두었지만, 워드에대해 더 알아본 결과로는 CPU가 한번에 처리할 수 있는 명령의 단위이다. 즉, 자신의 CPU가 32비트 이면, 한번에 처리할 수 있는 워드가 32비트라는 것을 알 수 있다. 64비트도 마찬가지.)

![컴퓨터 시스템 구조[4] - 저장 장치 계층 (Hierarchy)](https://t1.daumcdn.net/cfile/tistory/126D603D50FF4F170B)



### 1.2.3 입출력 구조

저장장치는 컴퓨터 내의 여러 형태의 입출력장치 중 하나이다. 운영체제 코드의 많은 부분들이 입출력을 관리하는 데 할애된다.

컴퓨터는 여러 장치 제어기와 CPU들로 구성되는데, 각 장치 제어기가 특정 타입의 장치를 담당한다. 장치 제어기에 따라 하나 이상의 장치가 부착되는 경우도 있다. 장치 제어기는 약간의 로컬 버퍼 저장장치와 특수 목적용 레지스터 집합을 유지한다.(집합을 유지? 가지고 있다는 뜻?)

장치 제어기는 자신이 제어하는 주변장치와 자신의 로컬 버퍼 저장장치 사이의 데이터 전송을 담당한다. 운영체제는 각 장치 제어기 마다 디바이스 드라이버를 가지고 있다. 이는 장치 제어기의 동작을 이해하고 운영체제의 다른 부분들에게 장치에 대한 일관된 인터페이스를 제공한다.(즉, API 정도로 보아도 괜찮을듯.)

입출력 연산의 시작은 이렇게 된다.

드라이버가 장치 제어기의 레지스터에 필요한 값 적재 -> 장치제어기가 레지스터 내용 조사 -> 이어 취할 동작을 결정(ex 키보드에서 한 문자를 읽어라.) -> 장치제어기가 장치의 입력을 자신의 로컬 버퍼에 저장 -> 자신이 연산 완료했음을 인터럽트로 드라이버에게 통보-> 드라이버가 제어를 운영체제에게 반환(입력 완료가 반환일 경우 데이터 또는 데이터에 대한 포인터를 같이 반환할 수 있음.) (입력 완료가 아닐 경우는 자신의(드라이버) 상태 정보를 반환.)

위의 인터럽트 구동 방식은 적은 양의 데이터를 전송하는 데에는 문제가 없지만, 대량의 데이터를 전송할 때(하드디스크에 저장)는 높은 오버헤드를 초래한다.

이러한 문제를 해결하기 위해 **직접 메모리 접근**(Direct memory Access, DMA)장치가 사용된다.

직접 메모리 접근 장치는 자신의 버퍼 및 포인터, 입출력 카운트 등을 세팅한 후 장치 제어기는 CPU의 개입 없이 메모리에서 자신의 버퍼 장치로, 또는 버퍼에서 메모리로 데이터 블록 전체를 전송할 수 있다. 속도가 느린 다른 장치처럼 한 바이트 마다 인터럽트가 발생하는 것이 아니라 블록 전송이 완료될 때마다 인터럽트가 발생한다. 따라서 CPU는 데이터 블록 전체가 전송을 하고 있는 동안 다른 작업을 수행할 수 있다.

몇몇 고가의 시스템은 버스 대신에 스위치 구조를 사용하여, 공유 버스를 사용하기 위해 장치들이 사이클을 경쟁하지 않고, 구성요소들 간의 동시 통신이 가능하다. 이 경우는 DMA의 사용이 더욱 효과적이다.

(책에 있는 그림을 보면 CPU와 장치가 직접적으로 입출력 요구와 데이터, 인터럽트를 주고 받는 것 처럼 보인다. 맞는 걸까)

